// Project     : linspace_meshgrid
// 
// Description : This package provides two functions, linspace and meshgrid,
//               that are useful for creating vectors or matrices for several
//               proposes.
//               It's useful if you want to closely replicate code in Matlab
//               or Python, without changing the this calls to loops inside
//               loops. Although the performance is worst then loops.
//               In same cases it is useful.
//
//               The linspace function generates a dynamic array that contains
//               a sequence of evenly spaced numbers between the start and end
//               values. The number of points is specified by the user.
//
//               The meshgrid function generates two dynamic arrays that contain
//               the X and Y coordinates of a grid. The X and Y coordinates can
//               be generated by the linspace function. The meshgrid function is
//               useful for creating a grid of points for plotting purposes or
//               others "Z" kind of values.
//
//               The test_linspace and test_meshgrid functions are provided to
//               show how to use the linspace and meshgrid functions.
//
// Author      : Joao Carvalho
// Date        : 2024-06-30
// 
// License     : MIT Open Source License
//
// Have fun!

package linspace_meshgrid

import "core:fmt"
import "core:math"
import "core:strings"
import "core:slice"
import "core:os"

//
// linspace
//

// Retuins a dynamic array filled with the values of a linspace.
linspace :: proc ( start : f64, end : f64, num : int ) ->
                 ( res_linspace  : [ dynamic ]f64,
                   error_msg     : string,
                   ok            : bool            ) {
    
    if num <= 0 {
        error_msg = "Number of points must be greater than zero.\n"
        return nil, error_msg, false
    }

    res_linspace = make( [ dynamic ]f64, num )
    if res_linspace == nil {
        error_msg = "Memory allocation failed.\n"
        return nil, error_msg, false
    } 

    step : f64 = ( end - start) /  f64( num - 1 )
    for i in 0 ..< num {
        res_linspace[ i ] = start + f64( i ) * step
    }

    // Ensure the end point is exactly as specified
    if num > 1 {
        res_linspace[ num - 1 ] = end
    }

    return res_linspace, "", true
}

test_linspace :: proc ( ) {

    fmt.println( "===>>> test_linspace( ) ...\n" )

    num_points := 11
    start      := -5.0
    end        :=  5.0

    lin_vec, error_msg, ok := linspace(start, end, num_points )
    defer delete( lin_vec )

    if ok {
        print_vec( "lin = ", lin_vec )
        fmt.println( "\nSuccess.\n")
    } else {
        fmt.printfln( error_msg )
    }
}

print_vec :: proc ( pre_str : string,
                    vec     : [ dynamic ]f64 ) {
    fmt.printf( "%s [ ", pre_str )
    for i in 0 ..< len( vec ) {
        fmt.printf( "%.2f ", vec[ i ] )
    }
    fmt.printfln( "]" )
}

print_vec_2d :: proc ( pre_str : string, X : [ ]f64,
                       len_x, len_y : int            ) {

    fmt.printfln( "%s", pre_str )
    for i in 0 ..< len_y {
        for j in 0 ..< len_x {
            fmt.printf( "%.2f ", X[ c2d_to_1d( j, i, len_x ) ] )
        }
        fmt.printfln( "" )
    }
}

//
// meshgrid
//

// Returns two dynamic arrays filled with the values of a meshgrid.
meshgrid :: proc ( x : [ dynamic ]f64,
                   y : [ dynamic ]f64 ) ->
                 ( res_meshgrid_x : [ dynamic ]f64,
                   res_meshgrid_y : [ dynamic ]f64,
                   error_msg      : string,
                   ok             : bool            ) {

    len_x := len( x )
    len_y := len( y )

    res_meshgrid_x = make( [ dynamic ]f64, len_x * len_y )
    if res_meshgrid_x == nil {
        error_msg = "Error: meshgrid( ), memory allocation failed.\n"
        return nil, nil, error_msg, false
    } 

    res_meshgrid_y = make( [ dynamic ]f64, len_x * len_y )
    if res_meshgrid_y == nil {
        error_msg = "Error: meshgrid( ), memory allocation failed.\n"
        return nil, nil, error_msg, false
    } 

    for i in 0 ..< len_y {
        for j in 0 ..< len_x {
            res_meshgrid_x[ c2d_to_1d( j,
                                       i,
                                       len( x ) ) ] = x[ j ]
            res_meshgrid_y[ c2d_to_1d( j,
                                       i,
                                       len( x ) ) ] = y[ i ]
        }
    }

    return res_meshgrid_x, res_meshgrid_y, "", true
}

c2d_to_1d :: #force_inline proc ( x, y, len_x : int ) -> int {
    
    return y * len_x + x
}

//  z = sin(x^2 + y^2)
calculate_z :: proc ( X : [ ]f64 , Y : []f64 ) ->
                    ( Z : [ dynamic ]f64 ) {

    assert( len( X ) == len( Y ),
            "Error: calculate_z( ), X and Y must have the same length.\n" )
    
    Z = make( [ dynamic ]f64, len( X ) )
    if Z == nil {
        fmt.printfln( "Error: calculate_z( ), memory allocation failed.\n" )
        os.exit( 1 )
    }

    tot_len := len( X )                   
    for i in 0 ..< tot_len {
        Z[ i ] = math.sin( X[ i ] * X[ i ] + Y[ i ] * Y[ i ])
    }

    return Z
}

test_meshgrid :: proc ( ) {

    fmt.println( "===>>> test_meshgrid( ) ...\n" )

    num_points := 5
    start      := -2.0
    end        :=  2.0
    X, error_msg_1, ok_1 := linspace( start, end, num_points )
    Y, error_msg_2, ok_2 := linspace( start, end, num_points )
    if !ok_1 || !ok_2 {
        fmt.printfln( error_msg_1 )
        fmt.printfln( error_msg_2 )
        os.exit( 1 )
    }
    defer delete( X )
    defer delete( Y )

    mg_X, mg_Y, error_msg, ok := meshgrid( X, Y )
    if !ok {
        fmt.printfln( error_msg )
        os.exit( 1 )
    }
    print_vec( "\nX = ", X )
    print_vec( "\nY = ", Y )

    Z := calculate_z( mg_X[ : ], mg_Y[ : ] )
    defer delete( Z )

    len_x := len( X )
    len_y := len( Y )
    print_vec_2d( "\nmg_X = ", mg_X[ : ], len_x, len_y )
    print_vec_2d( "\nmg_Y = ", mg_Y[ : ], len_x, len_y )
    print_vec_2d( "\nZ = ",    Z[ : ],    len_x, len_y )

    fmt.println( "\nSuccess.\n" )
}


